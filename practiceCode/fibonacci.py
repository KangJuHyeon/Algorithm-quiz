# 피보나치 수열이란? 
# 피보나치 수는 첫 번째와 두 번째 값이 1이고 다음부터는 그 전의 수와 그 전전의 수를 더하는 방식입니다.
# 첫 번째 값이 0으로 시작하는 경우도 있으며 다음과 같은 형태의 수열입니다.
# (0), 1, 1, 2, 3, 5, 8, 13 ...
# 2는 처음 1과 그 다음의 1을 합쳐서 계산되며, 3 역시 1과 2의 합으로 계산됩니다.
# 지금부터 파이썬으로 피보나치 수를 구하는 다양한 방법을 알아보자.

# 반복문으로 구현
# 이 방법은 직관적이면서 가장 효율적인 방법입니다.
def fibonacci(n):
    a, b = 0, 1
    for i in range(n):
        a, b = b, a + b
    return a
# 0으로 시작해서 첫 번째(n=1)와 두 번째(n=2)에서 1을 리턴하도록 했습니다.
# 일반적인 프로그래밍의 0으로 시작하는 인덱스와 혼동이 될 수 있기 때문에 0을 추가했습니다.
# 반복문이 실행될 때마다 a값이 b값으로 변경되며 b는 a와 b의 합으로 변경됩니다.

# 제너레이터 구현
# 1번 방식과 같이 결과만 전달받는 대신에 n까지의 값을 하나씩 받을 수도 있습니다.
# 제너레이터를 구현하면 0부터 n번 째 값까지 값을 순차적으로 받을 수 있습니다.
# yield란?
# 제너레이터는 이터레이터를 생성해주는 함수입니다. 
# 이터레이터는 클래스에 __iter__, __next__ 또는 __getitem__ 메서드를 구현해야 하지만 제너레이터는 함수 안에서 yield라는 키워드만 사용하면 끝입니다. 
# 그래서 제너레이터는 이터레이터보다 훨씬 간단하게 작성할 수 있습니다.
# 참고로 제너레이터는 발생자라고 부르기도 합니다. 
def fibonacci(n):
    a, b = 0, 1
    for i in range(n+1):
        yield a
        a, b = b, a + b

fibonacci = fibonacci(5)
for i, j in enumerate(fibonacci):
    print('Fibonacci({}): {}'.format(i, str(j)))

# 재귀 함수로 구현
# 재귀 함수를 통해 피보나치 수열을 구해봅시다.
# 피보나치를 사용해서 n이 1이나 2일 때 1을 리턴하도록 작성했고,
# 재귀 함수의 베이스 조건을 추가해주고 피보나치의 특성인 이전 값과 전전 값을 더해서 값을 구한다.
def fibonacci(n):
    if n == 0:
        return 0
    if n == 1 or n == 2:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
# 재귀 함수의 단점은 n이 증가하면 시간 복잡도(O(2n))가 가파르게 증가한다는 점입니다.
# 이러한 문제를 해결하기 위해 메모이제이션(Memoization)을 적용할 수 있습니다.


# 메모이제이션(Memoization) 구현
# 메모이제이션은 이전에 계산한 값을 저장해서 중복된 계산을 피하는 방법입니다.
# 메모이제이션을 통해 재귀 함수 구현의 단점인 성능을 대폭 향상시킬 수 있습니다.
from functools import lru_cache

@lru_cache(maxsize=None)
def fibonacci(n):
    if n == 0:
        return 0
    if n == 1 or n == 2:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
n = 50
print('Fibonacci({}): {}'.format(n, fib(n)))
# functools의 lru_cache를 통해 간단하게 메모이제이션을 구현할 수 있습니다.
# 간단하게 @lru_cache 데코레이터를 추가해서 이미 연산된 값을 모두 저장합니다

# 일반적인 재귀 함수 구현에서는 50번째 값을 구하는 것이 거의 불가능합니다.
# 이제 @lru_cache 데코레이터의 추가로 한 번 계산된 값은 바로 가져오기 때문에 빠르게 결과가 출력됩니다.