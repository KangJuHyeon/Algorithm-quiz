# 문제 읽기
# 네오는 평소 프로다가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.
# 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.
# 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

# 1. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져 있다.
# 2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
# 3. "지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
# 4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.

# 네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.

# n = 5, arr1 = [9,20,28,18,11], arr2 = [30,1,21,17,28], 출력 : ["#####","# # #", "### #", "# ##", "#####"]
# n = 6, arr1 = [46, 33, 33 ,22, 31, 50], arr2 = [27 ,56, 19, 14, 14, 10], 출력 : ["######", "### #", "## ##", " #### ", " #####", "### # "]

# 문제 접근
# format(arr1[i], "b")
# format(arr2[i], "b")
# 2진법을 합산하고 결과 값을 출력
# 2진법을 합산한 값을 #과 공백으로 나눠주는 로직
# 그것을 어디에 담을 것인지 정하고, 담은 값을 빈 배열에 담아서 리턴하면 된다.

# 카카오 비밀지도 다시 풀어보기
# 문제 풀이(1)
def solution(n, arr1, arr2):
    answer = []
    for i in range(n):
        tst = bin(arr1[i] | arr2[i])[2:] # 2진법으로 arr1과 arr2를 변환하고 비트연산을 활용해서 둘 중 하나를 tst에 담는다.
        #print(tst)

        a = [] # 2진수 값을 넣고 공백과 #을 나눠담을 변수 선언
        # if n <= 6:
        # testi = str(tst)
        # print(tst.zfill(6))
        for j in tst.zfill(n): # arr1, arr2를 2진법으로 변환하고 더해진 수를 공백과 #으로 나눠준다. zfill(n) n만큼 배열의 앞에 insert 해준다.
            if j == '0':
                a.append(' ')
            if j == '1':
                a.append('#')
        answer.append("".join(a))
    return answer

# print(solution(5, [9,20,28,18,11], [30,1,21,17,28]))
# 5, [9,20,28,18,11], [30,1,21,17,28]
# 6, [46, 33, 33 ,22, 31, 50], [27 ,56, 19, 14, 14, 10]

# 문제 풀이(2)
def solution(n, arr1, arr2):
    answer = []
    for i in range(n):
        arr1[i] = format(arr1[i], 'b') # 2진법 변환 1001 10100 11100 10010 1011
        arr2[i] = format(arr2[i], 'b') # 2진법 변환 11110 1 10101 10001 11100
        # print(arr1[i])
        # print(arr2[i])
        
        a = '' # 문자열 입력 값
        b = str(int(arr1[i])+int(arr2[i])) # 정수 값 arr1[i],arr2[i]의 2진법 값을 문자열로 변환 12111 10101 21201 20011 12111
        # print(str(int(arr1[i])+int(arr2[i])))
        if 0 < n: # n이 양수일 때
            # print(b)
            b = '0' * (n-len(b)) + b # 112121 211001 110012 11220 12221 111020 => 112121 211001 110012 011220 012221 111020
            # print(b)
        for j in b: # 2진법으로 합쳐진 arr1[i] + arr2[i] 값을 #과 공백으로 나눠준다.
            print(j)
            if j == '0': # a에서 각 자리의 수가 0이면 공백으로 바꿔주고,
                a = a + ' '
            else:        # 1이면 #으로 바꿔준다.
                a = a + '#'
        answer.append(a)
    return answer
print(solution(5, [9,20,28,18,11], [30,1,21,17,28])) 
# 5, [9,20,28,18,11], [30,1,21,17,28]
# 6, [46, 33, 33 ,22, 31, 50], [27 ,56, 19, 14, 14, 10]

# 문제 풀이(2)의 풀이 및 해석
# 위에 풀이는 2가나오는 이유는 2진수의 방법으로 arr1, arr2를 더해주지않아서 2가 나오는 것이다.
# 하지만 2가 나왔지만 12111 10101 이런식으로 나오는데 2는 #으로 들어가게 된다.
# 이유는 아직 찾지못했지만 로직대로 "만약에 j가 0과 같다면 공백을 넣고 그렇지않다면 #을 넣어줘" 라는 로직이라서 들어가는 것 같다.


# 다른사람의 Best 풀이
def solution(n, arr1, arr2):
    answer = []
    for i,j in zip(arr1,arr2): # zip함수를 이용해 arr1, arr2의 값을 나눈다.
        # print(i)
        print(j)
        a12 = str(bin(i|j)[2:]) # arr1[i] | arr2[j]를 2진법으로 비교 연산하고 슬라이싱으로 0b를 자르고 문자열로 변환후 a12로 담는다.
        a12=a12.rjust(n,'0') # rjust 함수를 사용해 오른쪽에 a12를 정렬하고 나머지는 n만큼 0으로 채운다.
        a12=a12.replace('1','#') # 1은 #으로 변환해서 a12에 담고,
        a12=a12.replace('0',' ') # 0이라면 공백으로 변환한 값으로 a12에 담는다.
        answer.append(a12) # 그것들을 빈 배열에 넣어준다.
    return answer 
print(solution(5, [9,20,28,18,11], [30,1,21,17,28])) 