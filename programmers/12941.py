# 문제 읽기
# 길이가 같은 배열 A, B 두개가 있습니다.
# 각 배열은 자연수로 이루어져 있고, 배열 A, B에서 각각 한개의 숫자를 뽑아 두 수를 곱합니다.
# 이 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다.
# 이 때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다.
# (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)

# A에서 첫번째 숫자인 1, B에서 첫번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5)
# A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21)
# A에서 세번째 숫자인 2, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29)

# 즉, 이 경우가 최소가 되므로 29를 리턴합니다.
# 배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 리턴하는 함수를 완성하세요.

# A = [1,4,2], B = [5,4,4] answer = 29
# A = [1,2], B = [3,4] answer = 10

# A에서 첫번째 숫자인 1, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 4) 다음, A에서 두번째 숫자인 2, B에서 첫번째 숫자인 3을 뽑아 곱하여 더합니다. (누적된 값 : 4 + 6 = 10)
# 이 경우가 최소이므로 10을 return 합니다.

# 문제 접근
# 누적된 값을 answer에 담고 i*j 곱해주는 변수를 하나 선언해보자.
# 이중 포문을 이용해서 곱할 생각이다.
# 근데 최종적으로 누적된 값이 최소가 되도록 만들려면 어떻게 해야되지?
# 이중포문에 min(i*j) 이런식으로 담아보면 될까?
# 테스트케이스 2번이 통과가 안되니, 최솟값을 만드는 방법에 대해 알아보자.
# 최솟값을 만드는 방법? [1,2,8],[6,3,4]
# i가 0일때 A[0] * B[0]는 1 * 6
# i가 1일때 A[1] * B[1]는 2 * 4
# i가 2일때 A[2] * B[2]는 8 * 3
# 두 행렬의 곱의 합 중 최솟값을 구하려면 제일 작은 수와 제일 큰 수를 곱하는 것이다.

# 수도코드(1)
# 이렇게 풀어보니 i가 인덱스를 다 돌면서 최솟값을 맞춰서 i값을 뽑아낸다. 예시) 1*5, 1*4, 1*4, 2*4, 2*4
# 두 번째 테스트케이스는 통과가 안되고 생각이 잘못됐다는 것을 깨달았다.
def solution(A,B):
    answer = 0 # 누적된 값을 담을 변수
    # minmum = A[0] * B[0] # 최소값을 구하는 방법을 변형
    for i in A:
        # print(i)
        # min(str(i*j))
        for j in B:
            # print(j)
            # print(i*j)
            if str(i * j) == min(str(i*j)): # 만약 i * j가 최솟값 i*j와 같다면
                print(i*j)
                # print(j)
                answer += i*j # 누적된 값과 더하기
                # print(i*j) 
                # print(answer)
    return answer

print(solution([1,4,2], [5,4,4]))

# 수도코드(2)
def solution(A,B):
    answer = 0 # 누적된 값을 담을 변수
    for i in range(len(A)):
        print(A[i] * B[i])
        answer += (A[i] * B[i])
    return answer
print(solution([1,4,2], [5,4,4]))

# 테스트케이스 2번을 생각해봐야된다. A = [1,2], B = [3,4]
# 1*4 = 4
# 2*3 = 6
# 4 + 6 = 10(최솟값)

# 문제풀이(1)
def solution(A,B):
    answer = 0 # 누적된 값을 담을 변수
    A.sort() # [1,2]
    B.sort(reverse = True) # [4,3]
    for i in range(len(A)):
        print(A[i] * B[i]) # 1*4 = 4 , 2 * 3 = 6
        answer += (A[i] * B[i]) # answer = 4 + 6 = 10
    return answer
print(solution([1,2], [3,4]))

# 다른사람이 푼 Best 풀이
def getMinSum(A,B):
    return sum(a*b for a, b in zip(sorted(A), sorted(B, reverse = True)))